### Building a trigger and execution engine for a ping service

The clearest way to show all these components of the toolkit is to build a
simple service that executes a `ping` entrypoint for configured components
whenever triggered. The complete entrypoint for the API is defined as follows:

```fsharp
// deislabs_ping_v01.witx
ping: function(req: string) -> string
```

The function is rather simple -- it takes a string as argument, and returns
another string. Whenever triggered, the execution engine will search for this
function in the components provided, execute it using the event data from the
trigger, then return the result. In the next sections, we will create a
timer-based trigger, write the engine implementation using the Glass toolkit,
then build an application targeting this service using C.

Before anything else, we have to decide on the "shape" of the data coming in and
out of the engine -- most often, this does not have to match the WITX definition
(but in simple cases it can):

```rust
#[async_trait]
pub trait Ping: Clone + Send + Sync + 'static {
    async fn execute(&self, input: String) -> Result<String, Error>;
}
```

Our triggers will be able to use an opaque `impl Ping`, pass it event data as a
string, then return the result also as a string. Now let's define the actual
trigger -- it is a simple timer which will fire every `interval` seconds and
call the `execute` function defined in the trait above:

```rust
pub struct TimerTrigger {
    pub interval: time::Duration,
}

impl TimerTrigger {
    pub async fn run(&self, engine: impl Ping) -> Result<(), Error> {
        let mut interval = tokio::time::interval(self.interval);
        loop {
            interval.tick().await;
            // every time the trigger fires, execute the engine's function with
            // custom data
            let res = engine
                .execute(format!(
                    "{}",
                    chrono::Local::now().format("%Y-%m-%d][%H:%M:%S")
                ))
                .await?;

            log::info!("{}\n", res);
        }
    }
}
```

> Note that you can use a trigger with any engine implementation -- write a new
> function implementation for `TimerTrigger` that take a different engine trait.

Now we need to write the concrete ping engine implementation:

```rust
// Automatically generate bindings based on the WITX file.
// This generates Rust code for all objects defined in the
// interface, and allows us to easily execute the component's
// entrypoint.
witx_bindgen_wasmtime::export!("deislabs_ping_v01.witx");

// DeislabsPingV01Data is internal state for our Ping modules,
// and the struct is automatically generated by WITX bindgen.
type WasiEngine = glass_engine::WasiExecutionEngine<DeislabsPingV01Data>;

#[derive(Clone)]
pub struct PingEngine(pub Arc<WasiEngine>);

// Implement the Ping trait defined above, so we can directly use
// a PingEngine with a trigger.
#[async_trait]
impl Ping for PingEngine {
    async fn execute(&self, input: String) -> Result<String, Error> {
        let (mut store, instance) = self.0.prepare_exec(None)?;

        // DeislabsPingV01 is a struct generated by WITX bindgen
        // that exposes the functions defined in the WITX definition
        // above.
        let pr = DeislabsPingV01::new(&mut store, &instance, |host| {
            host.runtime_data.as_mut().unwrap()
        })?;

        // Call the `ping` function from the component.
        let res = pr.ping(&mut store, input.as_str())?;

        Ok(res)
    }
}
```

> `prepare_exec` is implemented in the toolkit, and does all of the heavy
> lifting of setting up a Wasmtime store, engine, and linker, populating it with
> WASI and other custom implementations.
>
> Currently, the linker is populated with support for outbound HTTP and WASI NN,
> but hope to expose a way for engine implementations to choose that should they
> need it soon.

Some implementation details will most likely change in the future -- but they
will change towards making it _easier_ to write engines, and the code above
represents a full implementation for writing an engine today.

Now that we have an engine and a trigger, putting them together should be
straightforward:

```rust
    let engine = PingEngine(Arc::new(
        WasiExecutionContextBuilder::new(&config)?.build(&module)?,
    ));

    let trigger = TimerTrigger { interval: Duration::from_secs(2) };
    trigger.run(engine).await
```

> Note that the engine can also be configured to pull the component from a WASI
> registry.

We have the trigger and the engine, now we need to write a component that
implements the ping interface so it can be used in the new service -- let's see
an example in C (today you can write components in C, C++, and Rust, and hope to
have support for more soon):

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Auto-generated headers and
// implementation by WITX bindgen.
#include "deislabs_ping_v01.h"

// Omitting the implementation that
// prepends a char array to another
// char array.
void prepend(char *s, const char *t);

// Entrypoint for the component.
void deislabs_ping_v01_ping(
    deislabs_ping_v01_string_t *input,
    deislabs_ping_v01_string_t *output)
{
    // Allocate space for a new char array,
    // prepend "PONG: " to the message,
    // then update the return string to
    // point to it.
    char *out_msg = malloc(input->len + 6);
    strcpy(out_msg, input->ptr);
    prepend(out_msg, "PONG: ");

    output->len = input->len + 6;
    output->ptr = out_msg;
}
```

> [`yo-wasm`][yo] is a very helpful tool that scaffolds WebAssembly projects and
> configures compiler toolchains automatically, and can be used today for C,
> Rust, Swift, and AssemblyScript.

Once again, WITX bindgen generated all of the boilerplate necessary for us to
only implement the actual functionality of our application -- in this case, just
prepending "PONG: " to all inputs.

Now we can use a custom CLI to start the timer trigger with the engine
implementation defined above, and point it to the module we just built:

```bash
# create a ping trigger and send events to the ping engine
➜ glass ping --local crates/ping/tests/c/ctest.wasm
glass_engine] Created engine for module in: 8.5026ms

glass_ping] Total execution time: 34.5µs
glass_ping] PONG: 2021-08-14][03:35:48

glass_ping] Total execution time: 59.5µs
glass_ping] PONG: 2021-08-14][03:35:50
```

The Glass engine loads the component (for registry references it pulls it from
the registry and links it), pre-instantiates it, then every time the trigger
fires, instantiates the module, calls the `ping` function, then returns the
result.

> A note on performance -- if the engine has not been created, the creation
> latency can be thought of as the "cold start" cost associated with the actual
> Glass engine (the total "cold start" latency will vary based on a number of
> different factors) -- in this case around 9 milliseconds. This can be further
> optimized using a wide range of optimization techniques for WebAssembly
> modules.
>
> After the engine was created and the module pre-instantiated, the _total
> execution time_ (that is a "hot start") for our module is in the order of
> _microseconds_.

### Conclusion

In less than 50 lines of code, we went from an interface describing our API to a
complete implementation for a service that listens for external events and
executes WebAssembly components as a result. Our goal is to abstract all the
WebAssembly-specific bits, allow platform developers to define their own API
surface and implement the engines as easily as possible.

[yo]: https://github.com/deislabs/yo-wasm
